/*! \file buildandsortarrays.cxx
 *  \brief this file contains routines that build arrays used to sort/access the particle data local to the MPI domain
 */

#include "stf.h"

/// \name Simple group id based array building and group id reordering routines
//@{

///build group size array
Int_t *BuildNumInGroup(const Int_t nbodies, const Int_t numgroups, Int_t *pfof){
    Int_t *numingroup=new Int_t[numgroups+1];
    for (Int_t i=0;i<=numgroups;i++) numingroup[i]=0;
    for (Int_t i=0;i<nbodies;i++) if (pfof[i]>0) numingroup[pfof[i]]++;
    return numingroup;
}
///build the group particle index list (assumes particles are in ID order)
Int_t **BuildPGList(const Int_t nbodies, const Int_t numgroups, Int_t *numingroup, Int_t *pfof){
    Int_t **pglist=new Int_t*[numgroups+1];
    for (Int_t i=1;i<=numgroups;i++) {pglist[i]=new Int_t[numingroup[i]];numingroup[i]=0;}
    //for (Int_t i=0;i<nbodies;i++) if (ids[i]!=-1) {pglist[pfof[ids[i]]][numingroup[pfof[ids[i]]]++]=ids[i];}
    for (Int_t i=0;i<nbodies;i++) if (pfof[i]>0) pglist[pfof[i]][numingroup[pfof[i]]++]=i;
    return pglist;
}
///build the group particle index list (doesn't assume particles are in ID order and stores index of particle)
Int_t **BuildPGList(const Int_t nbodies, const Int_t numgroups, Int_t *numingroup, Int_t *pfof, Particle *Part){
    Int_t **pglist=new Int_t*[numgroups+1];
    for (Int_t i=1;i<=numgroups;i++) {pglist[i]=new Int_t[numingroup[i]];numingroup[i]=0;}
    for (Int_t i=0;i<nbodies;i++) {
        int pid=Part[i].GetID();
        if (pfof[pid]>0) pglist[pfof[pid]][numingroup[pfof[pid]]++]=i;
    }
    return pglist;
}
///build the group particle index list (doesn't assumes particles are in ID order)
Int_t **BuildPGList(const Int_t nbodies, const Int_t numgroups, Int_t *numingroup, Int_t *pfof, Int_t *ids){
    Int_t **pglist=new Int_t*[numgroups+1];
    for (Int_t i=1;i<=numgroups;i++) {pglist[i]=new Int_t[numingroup[i]];numingroup[i]=0;}
    for (Int_t i=0;i<nbodies;i++) if (pfof[i]>0) pglist[pfof[i]][numingroup[pfof[i]]++]=ids[i];
    return pglist;
}
///build the Head array which points to the head of the group a particle belongs to
Int_t *BuildHeadArray(const Int_t nbodies, const Int_t numgroups, Int_t *numingroup, Int_t **pglist){
    Int_t *Head=new Int_t[nbodies];
    for (Int_t i=0;i<nbodies;i++) Head[i]=i;
    for (Int_t i=1;i<=numgroups;i++)
        for (Int_t j=1;j<numingroup[i];j++) Head[pglist[i][j]]=Head[pglist[i][0]];
    return Head;
}
///build the Next array which points to the next particle in the group
Int_t *BuildNextArray(const Int_t nbodies, const Int_t numgroups, Int_t *numingroup, Int_t **pglist){
    Int_t *Next=new Int_t[nbodies];
    for (Int_t i=0;i<nbodies;i++) Next[i]=-1;
    for (Int_t i=1;i<=numgroups;i++)
        for (Int_t j=0;j<numingroup[i]-1;j++) Next[pglist[i][j]]=pglist[i][j+1];
    return Next;
}
///build the Len array which stores the length of the group a particle belongs to 
Int_t *BuildLenArray(const Int_t nbodies, const Int_t numgroups, Int_t *numingroup, Int_t **pglist){
    Int_t *Len=new Int_t[nbodies];
    for (Int_t i=0;i<nbodies;i++) Len[i]=0;
    for (Int_t i=1;i<=numgroups;i++)
        for (Int_t j=0;j<numingroup[i];j++) Len[pglist[i][j]]=numingroup[i];
    return Len;
}
///build the GroupTail array which stores the Tail of a group
Int_t *BuildGroupTailArray(const Int_t nbodies, const Int_t numgroups, Int_t *numingroup, Int_t **pglist){
    Int_t *GTail=new Int_t[numgroups+1];
    for (Int_t i=1;i<=numgroups;i++)
        GTail[i]=pglist[i][numingroup[i]-1];
    return GTail;
}
///build the group particle arrays need for unbinding procedure
Particle **BuildPartList(Int_t numgroups, Int_t *numingroup, Int_t **pglist, Particle* Part){
    Particle **gPart=new Particle*[numgroups+1];
    for (Int_t i=1;i<=numgroups;i++) {
        gPart[i]=new Particle[numingroup[i]];
        for (Int_t j=0;j<numingroup[i];j++) gPart[i][j]=Part[pglist[i][j]];
    }
    return gPart;
}
///build a particle list subset using array of indices
Particle *BuildPart(Int_t numingroup, Int_t *pglist, Particle* Part){
    Particle *gPart=new Particle[numingroup+1];
    for (Int_t j=0;j<numingroup;j++) gPart[j]=Part[pglist[j]];
    return gPart;
}

///reorder groups from largest to smallest
///\todo must alter so that after pfof is reorderd, so is numingroup array and pglist so that do not have to reconstruct this list 
///after reordering if numgroups==newnumgroups (ie, list has not shrunk)
void ReorderGroupIDs(const Int_t numgroups, const Int_t newnumgroups, Int_t *numingroup, Int_t *pfof, Int_t **pglist)
{
    PriorityQueue *pq=new PriorityQueue(newnumgroups);
    for (Int_t i = 1; i <=numgroups; i++) if (numingroup[i]>0) pq->Push(i, numingroup[i]);
    for (Int_t i = 1; i<=newnumgroups; i++) {
        Int_t groupid=pq->TopQueue(),size=pq->TopPriority();pq->Pop();
        for (Int_t j=0;j<size;j++) pfof[pglist[groupid][j]]=i;
    }
    delete pq;
}
void ReorderGroupIDs(const Int_t numgroups, const Int_t newnumgroups, Int_t *numingroup, Int_t *pfof, Int_t **pglist, Particle *Partsubset)
{
    PriorityQueue *pq=new PriorityQueue(newnumgroups);
    for (Int_t i = 1; i <=numgroups; i++) if (numingroup[i]>0) pq->Push(i, numingroup[i]);
    for (Int_t i = 1; i<=newnumgroups; i++) {
        Int_t groupid=pq->TopQueue(),size=pq->TopPriority();pq->Pop();
        for (Int_t j=0;j<size;j++) pfof[Partsubset[pglist[groupid][j]].GetID()]=i;
    }
    delete pq;
}

///similar to \ref ReorderGroupIDs but weight by value
void ReorderGroupIDsbyValue(const Int_t numgroups, const Int_t newnumgroups, Int_t *numingroup, Int_t *pfof, Int_t **pglist, Int_t *value)
{
#ifdef USEAHFPROP
    AHFPropData *ahftemp;
    if (iAHFreorder==1) ahftemp=new AHFPropData[newnumgroups+1];
#endif
    PriorityQueue *pq=new PriorityQueue(newnumgroups);
    for (Int_t i = 1; i <=numgroups; i++) if (numingroup[i]>0) pq->Push(i, value[i]);
    for (Int_t i = 1; i<=newnumgroups; i++) {
        Int_t groupid=pq->TopQueue();pq->Pop();
        for (Int_t j=0;j<numingroup[groupid];j++) pfof[pglist[groupid][j]]=i;
#ifdef USEAHFPROP
        if (iAHFreorder==1) ahftemp[i]=ahfpdata[groupid];
#endif
    }
#ifdef USEAHFPROP
    if (iAHFreorder==1) {
        if (newnumgroups>numgroups) {
            delete[] ahfpdata;
            ahfpdata=new AHFPropData[newnumgroups+1];
        }
        for (Int_t i=1;i<=newnumgroups;i++) ahfpdata[i]=ahftemp[i];
        delete[] ahftemp;
    }
#endif
    delete pq;
}
//@}
